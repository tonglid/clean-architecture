import "./chunk-J43GMYXM.js";

// node_modules/redux-first-history/build/es6/actions.js
var CALL_HISTORY_METHOD = "@@router/CALL_HISTORY_METHOD";
var LOCATION_CHANGE = "@@router/LOCATION_CHANGE";
var locationChangeAction = (location, action) => ({
  type: LOCATION_CHANGE,
  payload: { location, action }
});
function updateLocation(method) {
  return (...args) => ({
    type: CALL_HISTORY_METHOD,
    payload: { method, args }
  });
}
var push = updateLocation("push");
var replace = updateLocation("replace");
var go = updateLocation("go");
var goBack = updateLocation("goBack");
var goForward = updateLocation("goForward");
var back = updateLocation("back");
var forward = updateLocation("forward");

// node_modules/redux-first-history/build/es6/reachify.js
var reachify = (reduxHistory) => {
  let transitioning = false;
  let resolveTransition = () => {
  };
  return {
    _onTransitionComplete() {
      transitioning = false;
      resolveTransition();
    },
    listen(listener) {
      if (reduxHistory.listenObject) {
        return reduxHistory.listen(listener);
      }
      return reduxHistory.listen((location, action) => listener({ location, action }));
    },
    navigate(to, { state, replace: replace2 = false } = {}) {
      if (transitioning || replace2) {
        reduxHistory.replace(to, state);
      } else {
        reduxHistory.push(to, state);
      }
      transitioning = true;
      return new Promise((res) => resolveTransition = res);
    },
    get location() {
      return reduxHistory.location;
    },
    get transitioning() {
      return transitioning;
    }
  };
};

// node_modules/redux-first-history/build/es6/middleware.js
var createRouterMiddleware = ({ history, showHistoryAction }) => () => (next) => (action) => {
  if (action.type !== CALL_HISTORY_METHOD) {
    return next(action);
  }
  const method = action.payload.method;
  const args = action.payload.args;
  switch (method) {
    case "push":
      history.push(...args);
      break;
    case "replace":
      history.replace(...args);
      break;
    case "go":
      history.go(...args);
      break;
    case "back":
    case "goBack":
      history.goBack && history.goBack(...args);
      history.back && history.back(...args);
      break;
    case "forward":
    case "goForward":
      history.goForward && history.goForward(...args);
      history.forward && history.forward(...args);
      break;
  }
  if (showHistoryAction)
    return next(action);
};

// node_modules/redux-first-history/build/es6/reducer.js
var createRouterReducer = ({ savePreviousLocations = 0 }) => {
  const initialState = {
    location: null,
    action: null
  };
  const numLocationToTrack = isNaN(savePreviousLocations) ? 0 : savePreviousLocations;
  if (numLocationToTrack)
    initialState.previousLocations = [];
  return (state = initialState, { type, payload } = {}) => {
    if (type === LOCATION_CHANGE) {
      const { location, action } = payload || {};
      const previousLocations = numLocationToTrack ? [{ location, action }, ...state.previousLocations.slice(0, numLocationToTrack)] : void 0;
      return Object.assign(Object.assign({}, state), { location, action, previousLocations });
    }
    return state;
  };
};

// node_modules/redux-first-history/build/es6/create.js
var createReduxHistoryContext = ({ history, routerReducerKey = "router", reduxTravelling = false, showHistoryAction = false, selectRouterState, savePreviousLocations = 0, batch, reachGlobalHistory }) => {
  let listenObject = false;
  const callListener = (listener, location, action) => listenObject ? listener({ location, action }) : listener(location, action);
  if (typeof batch !== "function") {
    batch = (fn) => {
      fn();
    };
  }
  if (typeof selectRouterState !== "function") {
    selectRouterState = (state) => state[routerReducerKey];
  }
  const routerReducer = createRouterReducer({ savePreviousLocations });
  const routerMiddleware = createRouterMiddleware({ history, showHistoryAction });
  let isReduxTravelling = false;
  const handleReduxTravelling = (store) => {
    const locationEqual = (loc1, loc2) => loc1.pathname === loc2.pathname && loc1.search === loc2.search && loc1.hash === loc2.hash;
    return store.subscribe(() => {
      const sLoc = selectRouterState(store.getState()).location;
      const hLoc = history.location;
      if (sLoc && hLoc && !locationEqual(sLoc, hLoc)) {
        isReduxTravelling = true;
        history.push({ pathname: sLoc.pathname, search: sLoc.search, hash: sLoc.hash });
      }
    });
  };
  const createReduxHistory = (store) => {
    let registeredCallback = [];
    store.dispatch(locationChangeAction(history.location, history.action));
    if (reduxTravelling) {
      handleReduxTravelling(store);
    }
    history.listen((location, action) => {
      if (location.location) {
        action = location.action;
        location = location.location;
        listenObject = true;
      }
      if (isReduxTravelling) {
        isReduxTravelling = false;
        const routerState = selectRouterState(store.getState());
        registeredCallback.forEach((c) => callListener(c, routerState.location, routerState.action));
        return;
      }
      batch(() => {
        store.dispatch(locationChangeAction(location, action));
        const routerState = selectRouterState(store.getState());
        registeredCallback.forEach((c) => callListener(c, routerState.location, routerState.action));
      });
    });
    if (reachGlobalHistory) {
      reachGlobalHistory.listen(({ location, action }) => {
        if (action !== `POP`) {
          const loc = {
            pathname: location.pathname,
            search: location.search,
            hash: location.hash,
            key: location.key,
            state: location.state
          };
          batch(() => {
            store.dispatch(locationChangeAction(loc, action));
            const routerState = selectRouterState(store.getState());
            registeredCallback.forEach((c) => callListener(c, routerState.location, routerState.action));
          });
        }
      });
    }
    return {
      block: history.block,
      createHref: history.createHref,
      push: (...args) => store.dispatch(push(...args)),
      replace: (...args) => store.dispatch(replace(...args)),
      go: (...args) => store.dispatch(go(...args)),
      goBack: (...args) => store.dispatch(goBack(...args)),
      goForward: (...args) => store.dispatch(goForward(...args)),
      back: (...args) => store.dispatch(back(...args)),
      forward: (...args) => store.dispatch(forward(...args)),
      listen: (callback) => {
        if (registeredCallback.indexOf(callback) < 0) {
          registeredCallback.push(callback);
        }
        return () => {
          registeredCallback = registeredCallback.filter((c) => c !== callback);
        };
      },
      get location() {
        return selectRouterState(store.getState()).location;
      },
      get action() {
        return selectRouterState(store.getState()).action;
      },
      get length() {
        return history.length;
      },
      get listenObject() {
        return listenObject;
      }
    };
  };
  return { routerReducer, routerMiddleware, createReduxHistory };
};
export {
  CALL_HISTORY_METHOD,
  LOCATION_CHANGE,
  createReduxHistoryContext,
  go,
  goBack,
  goForward,
  push,
  reachify,
  replace
};
//# sourceMappingURL=redux-first-history.js.map
